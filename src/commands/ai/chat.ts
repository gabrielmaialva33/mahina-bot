import {
  ActionRowBuilder,
  ApplicationCommandOptionType,
  AttachmentBuilder,
  ButtonBuilder,
  ButtonStyle,
  ComponentType,
  EmbedBuilder,
  Message,
  MessageFlags,
} from 'discord.js'

import Command from '#common/command'
import MahinaBot from '#common/mahina_bot'
import Context from '#common/context'

export default class ChatCommand extends Command {
  private conversations: Map<string, Array<{ role: 'user' | 'assistant'; content: string }>> =
    new Map()

  constructor(client: MahinaBot) {
    super(client, {
      name: 'chat',
      description: {
        content: 'Chat inteligente com IA da NVIDIA - an√°lise de c√≥digo, gera√ß√£o e muito mais!',
        examples: [
          'chat Explique o que √© React',
          'chat code Crie uma API REST em Python',
          'chat analyze {c√≥digo}',
          'chat vision {imagem} O que voc√™ v√™?',
        ],
        usage: 'chat [mode] <mensagem>',
      },
      category: 'ai',
      aliases: ['ai', 'nvidia', 'gpt'],
      cooldown: 3,
      args: true,
      player: {
        voice: false,
        dj: false,
        active: false,
        djPerm: null,
      },
      permissions: {
        dev: false,
        client: ['SendMessages', 'ViewChannel', 'EmbedLinks'],
        user: [],
      },
      slashCommand: true,
      options: [
        {
          name: 'mode',
          description: 'Modo de opera√ß√£o da IA',
          type: ApplicationCommandOptionType.String,
          required: false,
          choices: [
            { name: 'üí¨ Chat Normal', value: 'chat' },
            { name: 'üíª Gera√ß√£o de C√≥digo', value: 'code' },
            { name: 'üîç An√°lise de C√≥digo', value: 'analyze' },
            { name: 'üìö Tutorial/Explica√ß√£o', value: 'explain' },
            { name: 'üêõ Debug de C√≥digo', value: 'debug' },
            { name: 'üé® UI/UX Helper', value: 'design' },
            { name: 'üëÅÔ∏è An√°lise de Imagem', value: 'vision' },
            { name: 'üß† Racioc√≠nio Avan√ßado', value: 'reasoning' },
          ],
        },
        {
          name: 'prompt',
          description: 'Sua mensagem ou pergunta',
          type: ApplicationCommandOptionType.String,
          required: true,
        },
        {
          name: 'language',
          description: 'Linguagem de programa√ß√£o (para modos de c√≥digo)',
          type: ApplicationCommandOptionType.String,
          required: false,
          choices: [
            { name: 'JavaScript/TypeScript', value: 'javascript' },
            { name: 'Python', value: 'python' },
            { name: 'Java', value: 'java' },
            { name: 'C++', value: 'cpp' },
            { name: 'Go', value: 'go' },
            { name: 'Rust', value: 'rust' },
            { name: 'SQL', value: 'sql' },
            { name: 'HTML/CSS', value: 'web' },
          ],
        },
        {
          name: 'model',
          description: 'Modelo de IA a usar',
          type: ApplicationCommandOptionType.String,
          required: false,
          choices: [
            { name: 'üåü Llama 4 Maverick (Multimodal)', value: 'llama-4-maverick' },
            { name: 'üß† DeepSeek R1 (Racioc√≠nio)', value: 'deepseek-r1' },
            { name: 'üíª Qwen Coder (C√≥digo)', value: 'qwen-coder' },
            { name: 'üöÄ Nemotron Ultra (Premium)', value: 'nemotron-ultra' },
            { name: '‚ö° Nemotron Nano (R√°pido)', value: 'nemotron-nano' },
          ],
        },
        {
          name: 'image',
          description: 'URL da imagem para an√°lise (modo vision)',
          type: ApplicationCommandOptionType.String,
          required: false,
        },
      ],
    })
  }

  public async run(client: MahinaBot, ctx: Context, args: string[]): Promise<any> {
    let mode: string
    let prompt: string
    let language: string | undefined
    let modelKey: string | undefined
    let imageUrl: string | undefined

    if (ctx.isInteraction) {
      mode = (ctx.options.get('mode')?.value as string) || 'chat'
      prompt = ctx.options.get('prompt')?.value as string
      language = ctx.options.get('language')?.value as string
      modelKey = ctx.options.get('model')?.value as string
      imageUrl = ctx.options.get('image')?.value as string
    } else {
      mode =
        args[0]?.toLowerCase() === 'code' ||
        args[0]?.toLowerCase() === 'analyze' ||
        args[0]?.toLowerCase() === 'explain' ||
        args[0]?.toLowerCase() === 'debug' ||
        args[0]?.toLowerCase() === 'design' ||
        args[0]?.toLowerCase() === 'vision' ||
        args[0]?.toLowerCase() === 'reasoning'
          ? args[0].toLowerCase()
          : 'chat'

      const actualArgs = mode === 'chat' ? args : args.slice(1)
      prompt = actualArgs.join(' ')
    }

    if (!prompt) {
      return await ctx.sendMessage('Por favor, forne√ßa uma mensagem ou pergunta!')
    }

    // Check for vision mode requirements
    if (mode === 'vision' && !imageUrl) {
      return await ctx.sendMessage('Por favor, forne√ßa uma URL de imagem para an√°lise!')
    }

    // Get enhanced NVIDIA service
    const nvidiaService = client.services.nvidiaEnhanced || client.services.nvidia

    if (!nvidiaService) {
      return await ctx.sendMessage({
        embeds: [
          {
            description:
              '‚ùå Servi√ßo de IA n√£o est√° configurado. Configure NVIDIA_API_KEY no ambiente.',
            color: client.config.color.red,
          },
        ],
      })
    }

    const loadingEmbed = new EmbedBuilder()
      .setColor(this.client.config.color.violet)
      .setDescription(`ü§ñ **Processando com ${modelKey ? `modelo ${modelKey}` : 'IA NVIDIA'}...**`)
      .setFooter({ text: 'Powered by NVIDIA AI' })

    const msg = await ctx.sendMessage({ embeds: [loadingEmbed] })

    try {
      // Get user conversation history
      const userId = ctx.author!.id
      const conversationKey = `${userId}-${mode}`

      if (!this.conversations.has(conversationKey)) {
        this.conversations.set(conversationKey, [])
      }

      const conversation = this.conversations.get(conversationKey)!

      // Set user model if specified
      if (modelKey && nvidiaService.setUserModel) {
        nvidiaService.setUserModel(userId, modelKey)
      }

      // Build system prompt based on mode
      const systemPrompt = this.getSystemPrompt(mode, language)

      // Add conversation context
      const context = conversation
        .slice(-5)
        .map((msg) => `${msg.role}: ${msg.content}`)
        .join('\n')

      // Prepare options for enhanced service
      const options: any = {
        temperature: mode === 'code' ? 0.2 : mode === 'reasoning' ? 0.6 : 0.7,
        maxTokens: mode === 'reasoning' ? 4096 : 2048,
      }

      if (imageUrl) {
        options.images = [imageUrl]
      }

      // Use appropriate method based on mode
      let response: string

      if (mode === 'reasoning' && nvidiaService.reasoning) {
        // Use specialized reasoning method
        response = await nvidiaService.reasoning(userId, prompt, context)
      } else if (
        (mode === 'code' || mode === 'analyze' || mode === 'debug') &&
        nvidiaService.analyzeCode
      ) {
        // Use code analysis method
        response = await nvidiaService.analyzeCode(
          userId,
          prompt,
          language || 'javascript',
          mode as any
        )
      } else if (nvidiaService.generateWithRAG && conversation.length > 0) {
        // Use RAG for better context
        response = await nvidiaService.generateWithRAG(userId, prompt)
      } else {
        // Default chat method
        response = await nvidiaService.chat(userId, prompt, context, systemPrompt, options)
      }

      // Add to conversation history
      conversation.push({ role: 'user', content: prompt })
      conversation.push({ role: 'assistant', content: response })

      // Keep conversation history limited
      if (conversation.length > 20) {
        conversation.splice(0, conversation.length - 20)
      }

      // Format and send response
      await this.sendFormattedResponse(ctx, msg, response, mode)

      // Add control buttons
      const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(
        new ButtonBuilder()
          .setCustomId('ai_new_chat')
          .setLabel('Nova Conversa')
          .setEmoji('üîÑ')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('ai_continue')
          .setLabel('Continuar')
          .setEmoji('üí¨')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('ai_code_format')
          .setLabel('Formatar C√≥digo')
          .setEmoji('üìù')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(mode !== 'code' && mode !== 'analyze' && mode !== 'debug'),
        new ButtonBuilder()
          .setCustomId('ai_export')
          .setLabel('Exportar')
          .setEmoji('üì§')
          .setStyle(ButtonStyle.Secondary)
      )

      await msg.edit({ components: [buttons] })

      // Handle button interactions
      const collector = msg.createMessageComponentCollector({
        componentType: ComponentType.Button,
        time: 300000, // 5 minutes
      })

      collector.on(
        'collect',
        async (interaction: {
          user: { id: any }
          reply: (arg0: { content: string; flags: any }) => any
          customId: any
        }) => {
          if (interaction.user.id !== ctx.author?.id) {
            return interaction.reply({
              content: 'Apenas o autor do comando pode usar esses bot√µes!',
              flags: MessageFlags.Ephemeral,
            })
          }

          switch (interaction.customId) {
            case 'ai_new_chat':
              this.conversations.delete(conversationKey)
              await interaction.reply({
                content: '‚úÖ Conversa reiniciada! Use o comando novamente para come√ßar.',
                flags: MessageFlags.Ephemeral,
              })
              break

            case 'ai_continue':
              await interaction.reply({
                content: 'üí¨ Digite sua pr√≥xima mensagem usando o comando!',
                flags: MessageFlags.Ephemeral,
              })
              break

            case 'ai_code_format':
              await this.formatCodeResponse(interaction, response)
              break

            case 'ai_export':
              await this.exportResponse(interaction, response, mode)
              break
          }
        }
      )
    } catch (error) {
      console.error('Error in chat command:', error)

      const errorEmbed = new EmbedBuilder()
        .setColor(this.client.config.color.red)
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao processar sua solicita√ß√£o.')
        .setFooter({ text: 'Tente novamente mais tarde' })

      await msg.edit({ embeds: [errorEmbed], components: [] })
    }
  }

  private getSystemPrompt(mode: string, language?: string): string {
    const basePrompts = {
      chat: `Voc√™ √© um assistente inteligente e amig√°vel. Responda de forma clara, √∫til e concisa.
             Use markdown para formatar suas respostas quando apropriado.`,

      code: `Voc√™ √© um expert em programa√ß√£o${language ? ` especializado em ${language}` : ''}.
             Gere c√≥digo limpo, eficiente e bem comentado.
             Sempre formate o c√≥digo em blocos markdown com syntax highlighting.
             Inclua explica√ß√µes breves sobre partes importantes do c√≥digo.`,

      analyze: `Voc√™ √© um analisador de c√≥digo experiente.
                Analise o c√≥digo fornecido identificando:
                - Poss√≠veis bugs ou problemas
                - Melhorias de performance
                - Boas pr√°ticas n√£o seguidas
                - Sugest√µes de refatora√ß√£o
                Seja construtivo e educativo em suas an√°lises.`,

      explain: `Voc√™ √© um professor de programa√ß√£o paciente e did√°tico.
                Explique conceitos de forma clara e progressiva.
                Use analogias quando apropriado.
                Inclua exemplos de c√≥digo simples para ilustrar conceitos.
                Divida explica√ß√µes complexas em passos menores.`,

      debug: `Voc√™ √© um debugger especialista.
              Analise o c√≥digo ou erro fornecido e:
              - Identifique a causa raiz do problema
              - Explique por que o erro est√° ocorrendo
              - Forne√ßa solu√ß√µes passo a passo
              - Sugira como prevenir erros similares no futuro`,

      design: `Voc√™ √© um especialista em UI/UX e front-end.
               Forne√ßa sugest√µes de design, melhores pr√°ticas de interface,
               e c√≥digo para componentes visuais modernos e acess√≠veis.
               Considere responsividade e experi√™ncia do usu√°rio.`,

      vision: `Voc√™ √© um especialista em an√°lise de imagens e vis√£o computacional.
               Analise imagens fornecidas e:
               - Descreva o que v√™ em detalhes
               - Identifique objetos, pessoas, texto ou elementos importantes
               - Forne√ßa insights sobre composi√ß√£o, cores e contexto
               - Responda perguntas espec√≠ficas sobre a imagem`,

      reasoning: `Voc√™ √© um especialista em racioc√≠nio l√≥gico e resolu√ß√£o de problemas complexos.
                  Analise problemas passo a passo:
                  - Decomponha o problema em partes menores
                  - Identifique padr√µes e rela√ß√µes
                  - Use l√≥gica dedutiva e indutiva
                  - Forne√ßa solu√ß√µes bem fundamentadas
                  - Considere m√∫ltiplas perspectivas`,
    }

    return basePrompts[mode as keyof typeof basePrompts] || basePrompts.chat
  }

  private async sendFormattedResponse(ctx: Context, msg: Message, response: string, mode: string) {
    // Split response if too long
    const chunks = this.splitResponse(response, 4000)

    for (const [i, chunk] of chunks.entries()) {
      const embed = new EmbedBuilder()
        .setColor(this.getModeColor(mode))
        .setDescription(chunk)
        .setFooter({
          text: `${this.getModeEmoji(mode)} ${mode.charAt(0).toUpperCase() + mode.slice(1)} Mode | Powered by NVIDIA`,
          iconURL:
            'https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Nvidia_logo.svg/1200px-Nvidia_logo.svg.png',
        })

      if (i === 0) {
        embed.setTitle(`${this.getModeEmoji(mode)} Resposta da IA`)
        await msg.edit({ embeds: [embed] })
      } else {
        await ctx.sendMessage({ embeds: [embed] })
      }
    }
  }

  private splitResponse(text: string, maxLength: number): string[] {
    const chunks: string[] = []
    let currentChunk = ''

    const lines = text.split('\n')
    for (const line of lines) {
      if (currentChunk.length + line.length + 1 > maxLength) {
        chunks.push(currentChunk)
        currentChunk = line
      } else {
        currentChunk += (currentChunk ? '\n' : '') + line
      }
    }

    if (currentChunk) {
      chunks.push(currentChunk)
    }

    return chunks
  }

  private getModeColor(mode: string): number {
    const colors: Record<string, number> = {
      chat: this.client.config.color.main,
      code: this.client.config.color.green,
      analyze: this.client.config.color.yellow,
      explain: this.client.config.color.blue,
      debug: this.client.config.color.red,
      design: this.client.config.color.violet,
      vision: this.client.config.color.green,
      reasoning: this.client.config.color.main,
    }
    return colors[mode] || this.client.config.color.main
  }

  private getModeEmoji(mode: string): string {
    const emojis: Record<string, string> = {
      chat: 'üí¨',
      code: 'üíª',
      analyze: 'üîç',
      explain: 'üìö',
      debug: 'üêõ',
      design: 'üé®',
      vision: 'üëÅÔ∏è',
      reasoning: 'üß†',
    }
    return emojis[mode] || 'ü§ñ'
  }

  private async formatCodeResponse(interaction: any, response: string) {
    // Extract code blocks from response
    const codeBlocks = response.match(/```[\s\S]*?```/g) || []

    if (codeBlocks.length === 0) {
      return interaction.reply({
        content: 'Nenhum bloco de c√≥digo encontrado na resposta!',
        flags: MessageFlags.Ephemeral,
      })
    }

    let formattedCode = ''
    for (const block of codeBlocks) {
      const cleanBlock = block.replace(/```(\w+)?\n?/, '').replace(/```$/, '')
      formattedCode += cleanBlock + '\n\n'
    }

    const attachment = new AttachmentBuilder(Buffer.from(formattedCode), { name: 'code.txt' })

    await interaction.reply({
      content: 'üìù C√≥digo extra√≠do e formatado:',
      files: [attachment],
      flags: MessageFlags.Ephemeral,
    })
  }

  private async exportResponse(interaction: any, response: string, mode: string) {
    const filename = `ai_${mode}_${Date.now()}.md`
    const attachment = new AttachmentBuilder(Buffer.from(response), { name: filename })

    await interaction.reply({
      content: `üì§ Resposta exportada como **${filename}**`,
      files: [attachment],
      flags: MessageFlags.Ephemeral,
    })
  }
}
